---
description: TypeScript coding conventions and patterns
globs: ["**/*.ts", "**/*.tsx"]
alwaysApply: false
---

# TypeScript Conventions

## Code Quality

### Prettier Formatting

**All code must be Prettier-formatted before committing.** This is enforced by:
- Pre-commit hooks (Husky + lint-staged)
- CI checks (`npm run format:check`)

Run `npm run format` to format all files, or rely on the pre-commit hook to auto-format staged files.

### ESLint Compliance

All code must pass ESLint with zero errors. Warnings should be addressed when possible.

## Imports

### Type-Only Imports

Always use inline type imports for type-only imports:

```ts
// ✅ Good
import { type User, fetchUser } from "./api"

// ❌ Bad - separate import statement
import type { User } from "./api"
import { fetchUser } from "./api"
```

### Import Order

1. Node.js built-ins
2. External packages
3. Internal modules (relative imports)

```ts
import path from "node:path"

import { z } from "zod"

import { validateInput } from "../utils/validation.js"
```

## Type Definitions

### Interfaces over Types

Prefer `interface` for object shapes:

```ts
// ✅ Good
interface UserProfile {
  name: string
  email: string
  age: number
}

// ❌ Bad
type UserProfile = {
  name: string
  email: string
  age: number
}
```

### Union String Types over Enums or Const Objects

Prefer simple union string types over enums or const object patterns:

```ts
// ✅ Good - simple union type
type Status = "idle" | "loading" | "success" | "error"

// ❌ Bad - const object (fake enum pattern)
const Status = {
  Idle: "idle",
  Loading: "loading",
  Success: "success",
  Error: "error",
} as const
type Status = (typeof Status)[keyof typeof Status]

// ❌ Bad - enum
enum Status {
  Idle = "idle",
  Loading = "loading",
  Success = "success",
  Error = "error",
}
```

When you need both runtime values and types, extract the union from an array:

```ts
// ✅ Good - array as source of truth
const SUPPORTED_FORMATS = ["json", "yaml", "toml"] as const
type SupportedFormat = (typeof SUPPORTED_FORMATS)[number]
```

## Functions

### Named Function Declarations

Use function declarations for pure functions, utility functions, and React components:

```ts
// ✅ Good - pure function
function formatCurrency(amount: number, currency: string): string {
  return new Intl.NumberFormat("en-US", { style: "currency", currency }).format(amount)
}

// ✅ Good - React component
function UserCard({ user }: UserCardProps): React.ReactElement {
  return <div>{user.name}</div>
}

// ❌ Bad - arrow function for pure function
const formatCurrency = (amount: number, currency: string): string => {
  return new Intl.NumberFormat("en-US", { style: "currency", currency }).format(amount)
}

// ❌ Bad - arrow function for component
const UserCard = ({ user }: UserCardProps) => {
  return <div>{user.name}</div>
}
```

### Arrow Functions for Callbacks

Use arrow functions for inline callbacks and closures:

```ts
// ✅ Good - inline callback
const activeUsers = users.filter((user) => user.isActive)

// ✅ Good - closure capturing context
function createHandler(config: Config) {
  return {
    onSubmit: (data) => {
      // Uses config from closure
    },
  }
}
```

### Explicit Return Types

All exported functions must have explicit return types:

```ts
// ✅ Good
export function parseConfig(input: string): Config {
  // ...
}

// ❌ Bad - missing return type
export function parseConfig(input) {
  // ...
}
```

## Type Guards

Use type guards for narrowing:

```ts
function isError(value: unknown): value is Error {
  return value instanceof Error
}

// Usage
if (isError(result)) {
  // result is typed as Error here
  console.log(result.message)
}
```

## Naming Conventions

### Variables

- **Boolean**: Use auxiliary verbs: `isLoading`, `hasError`, `shouldUpdate`
- **Collections**: Use plural: `items`, `users`, `options`
- **Functions**: Use verbs: `createUser`, `isValid`, `getConfig`

### Files

- **Components**: `UserCard.tsx` (PascalCase)
- **Utilities**: `formatCurrency.ts` (camelCase)
- **Constants/Config**: `constants.ts`, `config.ts` (camelCase)
- **Types**: `types.ts` or co-located

### Constants

Use SCREAMING_SNAKE_CASE for true constants:

```ts
const SUPPORTED_FORMATS = ["json", "yaml", "toml"] as const
const DEFAULT_TIMEOUT_MS = 5000
const API_BASE_URL = "https://api.example.com"
```

## Nullish Handling

### Prefer Nullish Coalescing

```ts
// ✅ Good
const value = input ?? defaultValue

// ❌ Bad - falsy check includes 0, ""
const value = input || defaultValue
```

### Prefer Optional Chaining

```ts
// ✅ Good
const city = user?.address?.city

// ❌ Bad
const city = user && user.address && user.address.city
```

## Comments

### JSDoc for Public APIs (TypeScript Style)

Use JSDoc without type annotations - let TypeScript handle the types:

```ts
// ✅ Good - TypeScript style (no type annotations in JSDoc)
/**
 * Formats a date relative to now (e.g., "2 hours ago").
 *
 * @param date - The date to format
 * @param locale - Optional locale for formatting
 * @returns Human-readable relative time string
 */
export function formatRelativeTime(date: Date, locale?: string): string {
  // ...
}

// ❌ Bad - JavaScript style (redundant type annotations)
/**
 * Formats a date relative to now.
 *
 * @param {Date} date - The date to format
 * @param {string} [locale] - Optional locale
 * @returns {string} Relative time string
 */
export function formatRelativeTime(date: Date, locale?: string): string {
  // ...
}
```

### Inline Comments for Non-Obvious Logic

```ts
// Intl.RelativeTimeFormat doesn't auto-select units,
// so we need to determine the appropriate unit ourselves
const units = selectTimeUnit(diffMs)
```
