---
description: TypeScript coding conventions and patterns
globs: ["**/*.ts", "**/*.tsx"]
alwaysApply: false
---

# TypeScript Conventions

## Imports

### Type-Only Imports

Always use inline type imports for type-only imports:

```ts
// ✅ Good
import { type RuleModule, ESLintUtils } from "@typescript-eslint/utils"

// ❌ Bad - separate import statement
import type { RuleModule } from "@typescript-eslint/utils"
import { ESLintUtils } from "@typescript-eslint/utils"
```

### Import Order

1. Node.js built-ins
2. External packages
3. Internal modules (relative imports)

```ts
import path from "node:path"

import { ESLintUtils } from "@typescript-eslint/utils"

import { createRule } from "../utils/create-rule.js"
```

## Type Definitions

### Interfaces over Types

Prefer `interface` for object shapes:

```ts
// ✅ Good
interface RuleOptions {
  allowedCallees: string[]
  maxDepth: number
}

// ❌ Bad
type RuleOptions = {
  allowedCallees: string[]
  maxDepth: number
}
```

### Union String Types over Enums or Const Objects

Prefer simple union string types over enums or const object patterns:

```ts
// ✅ Good - simple union type
type MessageId = "complexExpression" | "nestedMacro"

// ❌ Bad - const object (fake enum pattern)
const MessageId = {
  ComplexExpression: "complexExpression",
  NestedMacro: "nestedMacro",
} as const
type MessageId = (typeof MessageId)[keyof typeof MessageId]

// ❌ Bad - enum
enum MessageId {
  ComplexExpression = "complexExpression",
  NestedMacro = "nestedMacro",
}
```

When you need both runtime values and types, extract the union from an array:

```ts
// ✅ Good - array as source of truth
const LINGUI_MACROS = ["t", "Trans", "msg", "defineMessage"] as const
type LinguiMacro = (typeof LINGUI_MACROS)[number]
```

## Functions

### Named Function Declarations

Use function declarations for pure functions, utility functions, and React components:

```ts
// ✅ Good - pure function
function isLinguiMacro(node: TSESTree.Node): boolean {
  return node.type === "TaggedTemplateExpression"
}

// ✅ Good - React component
function UserProfile({ user }: UserProfileProps): React.ReactElement {
  return <div>{user.name}</div>
}

// ❌ Bad - arrow function for pure function
const isLinguiMacro = (node: TSESTree.Node): boolean => {
  return node.type === "TaggedTemplateExpression"
}

// ❌ Bad - arrow function for component
const UserProfile = ({ user }: UserProfileProps) => {
  return <div>{user.name}</div>
}
```

### Arrow Functions for Callbacks

Use arrow functions for inline callbacks and closures:

```ts
// ✅ Good
const listeners = nodes.filter((node) => isRelevant(node))

// ✅ Good - closure capturing context
function createVisitor(context: RuleContext) {
  return {
    CallExpression: (node) => {
      // Uses context from closure
    },
  }
}
```

### Explicit Return Types

All exported functions must have explicit return types:

```ts
// ✅ Good
export function createRule<TOptions extends unknown[]>(
  options: RuleCreatorOptions<TOptions>
): RuleModule<string, TOptions> {
  // ...
}

// ❌ Bad - missing return type
export function createRule(options) {
  // ...
}
```

## Type Guards

Use type guards for narrowing:

```ts
function isCallExpression(node: TSESTree.Node): node is TSESTree.CallExpression {
  return node.type === "CallExpression"
}

// Usage
if (isCallExpression(node)) {
  // node is typed as CallExpression here
  console.log(node.callee)
}
```

## Naming Conventions

### Variables

- **Boolean**: Use auxiliary verbs: `isLoading`, `hasError`, `shouldUpdate`
- **Collections**: Use plural: `items`, `rules`, `visitors`
- **Functions**: Use verbs: `createRule`, `isValid`, `getType`

### Files

- **Rules**: `rule-name.ts` (kebab-case)
- **Utils**: `createRule.ts` (camelCase)
- **Types**: `types.ts` or inline

### Constants

Use SCREAMING_SNAKE_CASE for true constants:

```ts
const LINGUI_MACROS = ["t", "Trans", "msg", "defineMessage"] as const
const DEFAULT_MAX_DEPTH = 1
```

## Nullish Handling

### Prefer Nullish Coalescing

```ts
// ✅ Good
const value = input ?? defaultValue

// ❌ Bad - falsy check includes 0, ""
const value = input || defaultValue
```

### Prefer Optional Chaining

```ts
// ✅ Good
const name = user?.profile?.name

// ❌ Bad
const name = user && user.profile && user.profile.name
```

## Comments

### JSDoc for Public APIs (TypeScript Style)

Use JSDoc without type annotations - let TypeScript handle the types:

```ts
// ✅ Good - TypeScript style (no type annotations in JSDoc)
/**
 * Creates an ESLint rule for Lingui macro validation.
 *
 * @param options - Rule configuration options
 * @returns Configured ESLint rule module
 */
export function createLinguiRule(options: RuleOptions): RuleModule {
  // ...
}

// ❌ Bad - JavaScript style (redundant type annotations)
/**
 * Creates an ESLint rule for Lingui macro validation.
 *
 * @param {RuleOptions} options - Rule configuration options
 * @returns {RuleModule} Configured ESLint rule module
 */
export function createLinguiRule(options: RuleOptions): RuleModule {
  // ...
}
```

### Inline Comments for Non-Obvious Logic

```ts
// TypeScript's getTypeAtLocation returns the *widened* type for literals,
// so we need to check the contextual type instead
const contextualType = typeChecker.getContextualType(node)
```
